(defun aoc-parse-line-segments ()
  (beginning-of-buffer)
  (let ((segments (make-vector (count-lines (point-min) (point-max)) nil))
        (line-num 0))
    (while (not (eobp))
      (let ((current-seg (thing-at-point 'line nil)))
        (aset segments line-num (aoc-parse-line-segment current-seg)))
      (setq line-num (+ 1 line-num))
      (forward-line 1))
    segments))

(defun aoc-parse-line-segment (str)
  (seq-into
   (mapcar
    (lambda (p) (seq-into (mapcar 'string-to-number (split-string p ",")) 'vector))
    (split-string str " -> "))
   'vector))

(defun aoc-vertical-points (segment)
  (let ((x (aref (aref segment 0) 0))
        (y1 (aref (aref segment 0) 1))
        (y2 (aref (aref segment 1) 1)))
    (let ((ys (if (< y1 y2) (number-sequence y1 y2) (number-sequence y2 y1))))
      (mapcar (lambda (n) (vector x n)) ys))))

(defun aoc-horizontal-points (segment)
  (let ((y (aref (aref segment 0) 1))
        (x1 (aref (aref segment 0) 0))
        (x2 (aref (aref segment 1) 0)))
    (let ((xs (if (< x1 x2) (number-sequence x1 x2) (number-sequence x2 x1))))
      (mapcar (lambda (n) (vector n y)) xs))))

(defun aoc-diagonal-points (segment)
  (let ((point-a (aref segment 0))
        (point-b (aref segment 1)))
    (let ((ax (aref point-a 0))
          (ay (aref point-a 1))
          (bx (aref point-b 0))
          (by (aref point-b 1)))
      (let ((x-range (if (> ax bx)
                         (seq-reverse (number-sequence bx ax))
                       (number-sequence ax bx)))
            (y-range (if (> ay by)
                         (seq-reverse (number-sequence by ay))
                       (number-sequence ay by))))
        (mapcar (lambda (n) (vector (car n) (cdr n))) (mapcar* #'cons x-range y-range))))))

(defun aoc-segment-points (segment)
  (let ((point-a (aref segment 0))
        (point-b (aref segment 1)))
    (cond ((eq (aref point-a 0) (aref point-b 0))
           (aoc-vertical-points segment))
          ((eq (aref point-a 1) (aref point-b 1))
           (aoc-horizontal-points segment))
          (t (aoc-diagonal-points segment)))))

(aoc-segment-points [[0 0] [8 8]])

(defun aoc-count-points (segments counts)
  (seq-do
   (lambda (s)
     (mapcar
      (lambda (p)
        (let ((c (gethash p counts 0)))
          (puthash p (+ 1 c) counts)))
      (aoc-segment-points s)))
   segments))

(defun aoc-count-overlaps (counts)
  (let ((overlap-count 0))
    (maphash
     (lambda (key value)
       (if (> value 1) (setq overlap-count (+ 1 overlap-count))))
     counts)
    overlap-count))

(defun aoc-hydro-nav ()
  (interactive)
  (let ((segments (aoc-parse-line-segments))
        (buf (get-buffer-create "aoc-day-5-part-2")))
    (select-window (split-window-vertically))
    (switch-to-buffer buf)
    (erase-buffer)
    (let ((point-counts (make-hash-table :test 'equal)))
      (aoc-count-points segments point-counts)
      (insert (format "%d" (aoc-count-overlaps point-counts))))))
